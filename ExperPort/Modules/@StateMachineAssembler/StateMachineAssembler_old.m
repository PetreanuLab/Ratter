% [sma]=StateMachineAssembler   An assembler for writing State Machine Matrices
%
% The StateMachineAssembler object is used to store State Machine matrix
% code (for the @RTLSM and the @SoftSMMarkII), as you build it; the code
% may have pointers and labels. Once completed, the assemble.m method
% disambiguates labels and builds a numeric state machine matrix. The
% send.m method assembles, calls the appropriate SetInputEvents.m,
% SetScheduledWaves.m, and SetOutputRouting.m for @RTLSM or @SoftSMMarkII,
% and then sends the assembled state matrix, ready for execution.
%
% See @StateMachineAssembler/Examples
%
% If StateMachineAssembler is passed an sma, returns it as is.
%
% If StateMachineAssembler is passed a struct, it tries to interpret it as
% a struct(sma), tries to revuild the sma as best it can, and returns that.
%

% Written by Carlos Brody October 2006; edited by Sebastien Awwad 2007,2008


function [sma] = StateMachineAssembler(varargin)
      
   if length(varargin)==1 && isa(varargin{1}, 'StateMachineAssembler'),
      sma = varargin{1};
      return;
   end;
   
   if length(varargin)==1 && isstruct(varargin{1}),
      % possibly a struct version of a previous version of
      % StateMachineAssembler. Let's try to reconstruct it as best we can. 
      
      sma_struct = varargin{1};
      varargin = varargin(2:end);
   else
      sma_struct = [];
   end;

   
   fnames = {'name', 'detectorFunctionName', 'inputNumber', 'happId'};
   hs = {
      'Cin',  'line_in',    1,  1   ; ...
      'Cout', 'line_out',   1,  2   ; ...
      'Lin',  'line_in',    2,  3   ; ...
      'Lout', 'line_out',   2,  4   ; ...
      'Rin',  'line_in',    3,  5   ; ...
      'Rout', 'line_out',   3,  6   ; ...
      'Chi',  'line_high',  1,  7   ; ...
      'Clo',  'line_low',   1,  8   ; ...
      'Lhi',  'line_high',  2,  9   ; ...
      'Llo',  'line_low',   2,  10  ; ...
      'Rhi',  'line_high',  3,  11  ; ...
      'Rlo',  'line_low',   3,  12  ; ...
      };
   
   default_happSpec = cell2struct(hs, fnames, 2);
   
   
   pairs = { ...
     'default_DOut'     0                 ; ...
     'default_happSpec' default_happSpec  ; ...
     'use_happenings'   0                 ; ...
     }; 
   singles = { ...
     'no_dead_time_technology',     'inputarg', 'no_dead_time_technology',     '' ; ...
     'standard_state35_technology', 'inputarg', 'standard_state35_technology', '' ; ...
     'full_trial_structure',        'inputarg', 'full_trial_structure',        '' ; ...
     };
   parseargs(varargin, pairs, singles);
   
   if isempty(default_DOut),
     error('you passed in an empty matrix as a default_DOut -- can''t do that');
   end;
   if numel(default_DOut) ~= 1 || default_DOut ~= 0,
     % error('sorry, default_DOut different to zero not yet supported');
   end;
   
   default_input_map = { ...
     'Cin'    1   ; ...
     'Cout'   2   ; ...
     'Lin'    3   ; ...
     'Lout'   4   ; ...
     'Rin'    5   ; ...
     'Rout'   6   ; ...
     'Tup'    7   ; ...
   };
   
   default_self_timer_map = { ...
     'Timer'  8   ; ...
   };
   
   default_output_map = { ...
     'DOut'        9 ; ...
     'SoundOut'   10 ; ...
   };

   
   sma = struct( ...
     'input_map',           {default_input_map},  ...
     'self_timer_map',      {default_self_timer_map},  ...
     'output_map',          {default_output_map}, ...
     'use_happenings',      use_happenings, ...
     'happSpec',            default_happSpec, ...
     'happList',            {cell(0, 1)},  ...
     'state_name_list',     {cell(0,3)},   ...
     'current_state',       0,             ...
     'states',              zeros(0, 10),  ...
     'default_actions',     {cell(0, 1)},  ...
     'current_iti_state',   0,             ...
     'iti_states',          zeros(0, 10),  ...
     'default_iti_actions', {cell(0, 1)},  ...
     'dio_sched_wave_cols', 8, ... 
     'sched_waves',         struct('name', {}, 'id', {}, 'in_column', {}, ...
                                   'out_column', {}, 'dio_line', {}, ...
                                   'preamble', {}, 'sustain', {}, ...
                                   'refraction', {}, 'sound_trig',{}, ...
                                   'loop', {}, ...
                                   'trigger_on_up', {}, 'untrigger_on_down', {}), ...
     'pre35_curr_state',   -1,             ...
     'default_DOut',        default_DOut,  ...   
     'full_trial_structure',             0, ...
     'prepare_next_trial_state_names',{{}}, ...
     'prepare_next_trial_states',       []  ...
...%     'globals',             '',             ... % <~> new RT system embedded c functionality
...%     'initfunc',            '',             ... % <~> new RT system embedded c functionality
...%     'cleanupfunc',         '',             ... % <~> new RT system embedded c functionality
...%     'transitionfunc',      '',             ... % <~> new RT system embedded c functionality
...%     'tickfunc',            '',             ... % <~> new RT system embedded c functionality
...%     'treshfunc',           '',             ... % <~> new RT system embedded c functionality
...%     'entryfuncs',          {cell(0,2)},    ... % <~> new RT system embedded c functionality
...%     'entrycode',           {cell(0,2)},    ... % <~> new RT system embedded c functionality
...%     'exitfuncs',           {cell(0,2)},    ... % <~> new RT system embedded c functionality
...%     'exitcode',            {cell(0,2)},    ... % <~> new RT system embedded c functionality
...%     'flagUsingEmbC',       false           ... % <~> flag specifying dependencies of this SMA object
   );
   
   if ~isempty(sma_struct)
      % possibly a struct version of a previous version of
      % StateMachineAssembler. Let's try to reconstruct it as best we can.

      old_fnames = fieldnames(sma_struct);
      for i=1:numel(old_fnames),
         if isfield(sma, old_fnames{i}),
            sma.(old_fnames{i}) = sma_struct.(old_fnames{i});
         end;
      end;
      
      sma = class(sma, 'StateMachineAssembler');
      return;
   end;


   sma = class(sma, 'StateMachineAssembler');
   
   if ischar(inputarg),
      switch inputarg,
        case '',
       
        case 'no_dead_time_technology',
          sma = initialize_no_dead_time_structure(sma);
         
        case 'full_trial_structure',
          sma = initialize_full_trial_structure(sma);
          
        case 'standard_state35_technology'
          error(sprintf(['Sorry, standard_state35_technology not ' ...
            'implemented yet. Use no_dead_time_technology.\n']));
          % sma = initialize_standard_state35_structure(sma);
        otherwise,
         error(sprintf(['Don''t know this flag for creating a ' ...
           'StateMachineAssembler object: %s\n'], inputarg));
      end;
   end;
   
   return;
   
   